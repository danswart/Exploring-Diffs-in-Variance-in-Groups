---
title: "Exploring Sample Variances by Type of Universe"
subtitle: "Random v Sequential"
description: ""
authors: 
  - name: "Dan Swart, CPA (ret)"
  - name: "Claude Sonnet 4.5"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 16pt
    mainfont: "Cabin"
  

    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: true
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: true
    error: false
    warning: false
    message: false
    cache: false


---


```{r}
#| label: setup
#| include: false


# install.packages(c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# # load libraries - NOT NEEDED


# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Options
options(scipen = 999)
options(qic.clshade = T) # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.linecol = 'black') # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.signalcol = "firebrick") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.targetcol = "purple") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(DT.options = list(dom = 'pBlfrti')) # Add buttons, filtering, and top (t) pagination controls
options(shiny.maxRequestSize = 50 * 1024^2) # Set upload maximum to 50 MB
options(tigris_use_cache = TRUE)


flextable::set_flextable_defaults(
  font.size = 14, 
  font.family = "Cabin",
  font.color = "black",
  table.layout = "fixed",
  border.color = "darkgray",
  padding.top = 3, padding.bottom = 3,
  padding.left = 4, padding.right = 4,
  line_spacing = 1.3,
  digits = 2,
  decimal.mark = ".",
  big.mark = " ",
  na_str = "<na>")
  
  # flextable::theme_alafoli()	|>  # BLAH
  # flextable::theme_apa()  # THIS IS NICE
  # flextable::theme_booktabs() |>  # NICE, MORE COMPACT
  # flextable::theme_box() |>   # OK, INCLUDES CELL BORDERS
  # flextable::theme_tron() |>  # 'DARK MODE' BLUE TEXT
  # flextable::theme_tron_legacy() |>   # 'DARK MODE' YELLOW TEXT
  # flextable::theme_vader() |>    # 'DARK MODE' WHITE TEXT
  # flextable::theme_vanilla() |>   # NOT SPECIAL
  # flextable::theme_zebra()	|>
  #
  # flextable::bg(bg = "palegreen", part = "header")
  # flextable::bg(i = 8, bg = "yellow", part = "body")   OR
  # 



# Set global theme for consistent plots
ggplot2::theme_set(
  ggplot2::theme_minimal(base_size = 20) +
    ggplot2::theme(
      plot.title.position = "plot",
      plot.title = ggtext::element_textbox_simple(
        family = "Cabin",
        face = "bold",
        color = "darkgreen",
        size = 26,
        fill = "yellow",
        lineheight = 1.2,
        padding = ggplot2::margin(5.5, 5.5, 0.0, 5.5),
        margin = ggplot2::margin(0, 0, 5.5, 0)
      ),
      plot.subtitle = ggtext::element_textbox_simple(
        family = "Cabin",
        color = "darkgreen",
        face = "bold",
        size = 24,
        fill = "yellow",
        lineheight = 1.2,
        padding = ggplot2::margin(5.5, 5.5, 5.5, 5.5),
        margin = ggplot2::margin(10.5, 0, 5.5, 0)
      ),
      plot.caption = ggtext::element_markdown(
        family = "Cabin",
        size = 22,
        hjust = 1,
        color = "darkblue",
        face = "italic",
        fill = "yellow",
        lineheight = 1.0
      ),
      axis.text.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.x = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20),
        # ggplot2::element_blank(),
      axis.text.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20,
        angle = 45,
        hjust = 1
      ),
        # ggplot2::element_blank(),
      axis.title.y = ggtext::element_markdown(
        family = "Cabin",
        face = "bold",
        color = "blue",
        size = 20),
        # ggplot2::element_blank(),
      strip.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black",
        size = ggplot2::rel(1.1),
        face = "italic",
        margin = ggplot2::margin(2, 0, 0.5, 0, "lines")
      ),
      axis.text = ggtext::element_markdown(
        family = "Cabin",
        color = "black"),
      panel.background = ggplot2::element_rect(fill = "white", color = NA),
      plot.background = ggplot2::element_rect(fill = "white", color = NA),
      legend.position = "none",
      panel.spacing.x = grid::unit(1.5, "cm"),
      panel.spacing.y = grid::unit(1.5, "cm"),
      plot.margin = ggplot2::margin(20, 20, 20, 20, "pt")
    )
)



  
# Set seed for reproducibility
base::set.seed(123)

```



```{r}
# Define each universe

# Create a random universe (1000 random integers between 1 and 1000)
random_universe <- base::sample(1:1000, 1000, replace = TRUE)

# Create non-random universes (several options)


# Option 1: Sequential numbers
sequential_universe <- 1:1000


# Option 2: Autocorrelated but realistic (e.g., school district scores)
set.seed(42)
n_months <- 1000
district_baseline <- 75  # District tends to score around 75th percentile

# Create autocorrelated scores using AR(1) process
autocorr_universe <- base::numeric(n_months)
autocorr_universe[1] <- district_baseline + stats::rnorm(1, 0, 8)

for(i in 2:n_months) {
  # Each month's score depends on last month's + some random variation
  autocorr_universe[i] <- 0.1 * autocorr_universe[i-1] + 0.7 * district_baseline + stats::rnorm(1, 0, 8)
}


# Keep scores realistic (0-100 range)
autocorr_universe <- base::pmax(0, base::pmin(100, autocorr_universe))



# Option 3: Clustered data (4 distinct clusters)
clustered_universe <- c(
  stats::rnorm(250, mean = 100, sd = 20),
  stats::rnorm(250, mean = 300, sd = 20),
  stats::rnorm(250, mean = 600, sd = 20),
  stats::rnorm(250, mean = 900, sd = 20)
)
# Round to integers and ensure values are within 1-1000
clustered_universe <- base::pmin(1000, base::pmax(1, base::round(clustered_universe)))


# Option 4: Bimodal distribution
bimodal_universe <- base::c(
  stats::rnorm(500, mean = 250, sd = 100),
  stats::rnorm(500, mean = 750, sd = 100)
)
# Round to integers and ensure values are within 1-1000
bimodal_universe <- base::pmin(1000, base::pmax(1, base::round(bimodal_universe)))


# Option 5: Increasing variance (first half has low variance, second half high)
increasing_var_universe <- c(
  stats::rnorm(500, mean = 500, sd = 50),
  stats::rnorm(500, mean = 500, sd = 200)
)
# Round to integers and ensure values are within 1-1000
increasing_var_universe <- base::pmin(1000, base::pmax(1, base::round(increasing_var_universe)))
 


```

# Random Universe v Auto-Correlated Universe

```{r}
# Step 2: Function to take samples and calculate variance
calculate_sample_variances <- function(universe, sample_size, num_samples = 100) {
  variances <- base::numeric(num_samples)
  for(i in 1:num_samples) {
    sample_data <- base::sample(universe, sample_size)
    variances[i] <- stats::var(sample_data)
  }
  return(variances)
}

```

```{r}
# Step 3: Experiment with different sample sizes
sample_sizes <- c(10, 30, 50, 100, 200, 500)
results <- list()

# define the nonrandom universe type
for(size in sample_sizes) {
  random_variances <- calculate_sample_variances(random_universe, size)
  nonrandom_variances <- calculate_sample_variances(autocorr_universe, size)
  
  results[[paste0("size_", size)]] <- list(
    random = random_variances,
    nonrandom = nonrandom_variances
  )
}

```


```{r}
# Convert nested list to a data frame
results_df <- data.frame()

for(size_name in names(results)) {
  # Extract the numeric size from the name
  size <- base::as.numeric(base::gsub("size_", "", size_name))
  
  # Add random universe results
  random_data <- base::data.frame(
    sample_size = size,
    variance = results[[size_name]]$random,
    universe_type = "random"
  )
  
  # Add non-random universe results
  nonrandom_data <- base::data.frame(
    sample_size = size,
    variance = results[[size_name]]$nonrandom,
    universe_type = "Sequential"
  )
  
  # Combine the data
  results_df <- base::rbind(results_df, random_data, nonrandom_data)
}

# Now you can plot with ggplot
ggplot2::ggplot(results_df, ggplot2::aes(x = base::factor(sample_size), y = variance, color = universe_type)) +
  ggplot2::geom_boxplot() +
  ggplot2::labs(
    title = "Sample Variance by Sample Size and Universe Type",
    subtitle = "Random v Sequential",
    x = "Sample Size",
    y = "Variance",
    color = "Universe Type"
  ) 

```

```{r}
# Calculate p-values comparing variances across universe types for each sample size
result_stats <- data.frame()

for(size_name in names(results)) {
  # Extract the numeric size from the name
  size <- base::as.numeric(base::gsub("size_", "", size_name))
  
  # Run F-test to compare variances
  f_test <- stats::var.test(results[[size_name]]$random, results[[size_name]]$nonrandom)
  
  # Store results
  result_stats <- base::rbind(result_stats, base::data.frame(
    sample_size = size,
    p_value = f_test$p.value,
    significant = f_test$p.value < 0.05
  ))
}

```

```{r}
# Add p-values to the plot
ggplot2::ggplot(results_df, ggplot2::aes(x = base::factor(sample_size), y = variance, color = universe_type)) +
  ggplot2::geom_boxplot() +
  ggplot2::geom_text(data = result_stats, 
            ggplot2::aes(x = base::factor(sample_size), 
                y = base::max(results_df$variance) * 1.1,
                label = base::sprintf("p = %.3f", p_value)),
            inherit.aes = FALSE) +
  ggplot2::labs(
    title = "Sample Variance by Sample Size and Universe Type",
    subtitle = "With p-values from F-test comparing variances",
    x = "Sample Size",
    y = "Variance",
    color = "Universe Type"
  ) 

```

```{r}
# Calculate mean and confidence intervals for your variances
results_summary <- results_df |>
  dplyr::group_by(sample_size, universe_type) |>
  dplyr::summarize(
    mean_variance = base::mean(variance),
    sd_variance = stats::sd(variance),
    n = dplyr::n(),
    se = sd_variance/sqrt(n),
    ci_lower = mean_variance - 1.96*se,
    ci_upper = mean_variance + 1.96*se
  )

# Plot with confidence intervals
ggplot2::ggplot(results_summary, 
                ggplot2::aes(x = base::factor(sample_size), y = mean_variance, color = universe_type)) +
  ggplot2::geom_point(size = 3) +
  ggplot2::geom_errorbar(
    ggplot2::aes(ymin = ci_lower, ymax = ci_upper), width = 0.2) +
  ggplot2::labs(
    title = "Mean Sample Variance with 95% Confidence Intervals",
    x = "Sample Size",
    y = "Mean Variance",
    color = "Universe Type"
  ) 

```


```{r}
# Calculate the difference in variance between random and non-random for each sample size
diff_data <- data.frame()

for(size_name in names(results)) {
  size <- base::as.numeric(base::gsub("size_", "", size_name))
  
  # Calculate differences for each simulation pair
  n_sims <- base::length(results[[size_name]]$random)
  differences <- results[[size_name]]$random - results[[size_name]]$nonrandom
  
  diff_data <- base::rbind(diff_data, base::data.frame(
    sample_size = base::rep(size, n_sims),
    variance_difference = differences
  ))
}

# Plot the differences
ggplot2::ggplot(diff_data, 
                ggplot2::aes(x = base::factor(sample_size), y = variance_difference)) +
  ggplot2::geom_boxplot() +
  ggplot2::geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  ggplot2::labs(
    title = "Difference in Variance (Random - Non-random)",
    subtitle = "Differences significantly different from zero indicate distinct populations",
    x = "Sample Size",
    y = "Variance Difference"
  ) 

```

```{r}
ggplot2::ggplot(results_df,
                ggplot2::aes(x = variance, fill = universe_type)) +
  ggplot2::geom_density(alpha = 0.5) +
  ggplot2::geom_vline(data = results_df |> dplyr::group_by(universe_type) |> 
               dplyr::summarize(mean_var = base::mean(variance)),
             ggplot2::aes(xintercept = mean_var, color = universe_type),
             linetype = "dashed", linewidth = 1) +
  ggplot2::facet_wrap(~sample_size, scales = "free") +
  ggplot2::labs(title = "Distribution of Variances by Sample Size",
       subtitle = "Vertical lines show means, while distributions show overall spread")
```


```{r}
# For each sample size, perform a one-sample t-test on the differences
diff_stats <- data.frame()

for(size_name in names(results)) {
  size <- base::as.numeric(base::gsub("size_", "", size_name))
  
  # Calculate differences for this sample size
  differences <- results[[size_name]]$random - results[[size_name]]$nonrandom
  
  # Perform one-sample t-test against Î¼ = 0
  t_test <- stats::t.test(differences, mu = 0)
  
  # Store results
  diff_stats <- base::rbind(diff_stats, base::data.frame(
    sample_size = size,
    mean_diff = base::mean(differences),
    p_value = t_test$p.value,
    significant = t_test$p.value < 0.05,
    lower_ci = t_test$conf.int[1],
    upper_ci = t_test$conf.int[2]
  ))
}

# # Print the results
# print(diff_stats)
```


```{r}
# Plot the differences with confidence intervals
ggplot2::ggplot(diff_stats, 
                ggplot2::aes(x = base::factor(sample_size), y = mean_diff)) +
  ggplot2::geom_point(size = 3) +
  ggplot2::geom_errorbar(ggplot2::aes(ymin = lower_ci, ymax = upper_ci), width = 0.2) +
  ggplot2::geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  ggplot2::labs(
    title = "Mean Difference in Variance (Random - Non-random)",
    subtitle = "With 95% confidence intervals",
    x = "Sample Size",
    y = "Mean Difference in Variance"
  ) 

```


