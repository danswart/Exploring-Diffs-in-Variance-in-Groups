---
title: "Exploring Sample Variances by Distribution Type"
subtitle: ""
description: ""
authors: 
  - name: "Dan Swart, CPA (ret)"
  - name: "Claude Sonnet 4.5"
date: today
date-format: long
# bibliography: manual-refs.bib
format:
  html:
    resources:
      - reference-backlinks.js
    include-after-body:    
      - text: |
          # <script type="text/javascript" src="reference-backlinks.js"></script>
    default: true         
    code-copy: true
    code-link: true        # This adds individual buttons
    code-fold: true        # Hide code by default, show on click
    code-summary: "Show the code"
    code-overflow: wrap
    code-block-bg: "#FAEBD7"
    code-block-border-left: "#31BAE9"
    embed-resources: true
    include-in-header:
      - text: 
          <link href="https://fonts.googleapis.com/css2?family=Lato&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Fira+Mono&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Montserrat&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Cabin&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">
          <link href="https://fonts.googleapis.com/css2?family=Schoolbell&display=swap" rel="stylesheet">
      - header.html
    css:
      - swart.css
      - tachyons.min.css
      - r-colors.css
    fontsize: 18pt
    lightbox: true
    page-layout: full
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    html-math-method: katex
    df-print: paged
    toc: true
    toc-float: true
    citeproc: true
    link-citations: true
    linestretch: 1.0
    
    
    
  typst:
    fig-width: 12
    fig-height: 10
    fig-dpi: 300
    margin:
      x: 1in
      y: 1in
    toc: true
    fontsize: 14pt
    mainfont: "Cabin"
    
  revealjs:
    slide-number: true
    transition: fade
    code-overflow: wrap
    center: true
    smaller: true
    scrollable: true
    chalkboard: true
    multiplex: false
    theme: solarized
    reference-location: margin
    logo: img/red-cross-640-435.png
    footer: "Footer text"
    code-block-height: 650px



  # docx:
  #   highlight-style: github
  #   fig_caption: true



editor: source

quarto:
  render:
    cache-refresh: true


# for .qmd filesd
execute:
  echo: false
  message: false
  warning: false
  eval: true
  fig-width: 12
  fig-height: 10


# for .rmd files
knitr:
  opts_chunk:
    echo: false
    error: false
    warning: false
    message: false
    cache: false

---


```{r}
#| label: setup
#| include: false
# R version 4.4.3 (2025-02-28)
# Platform: x86_64-apple-darwin20
# Running under: macOS Sequoia 15.6.1
# Rstudio 2025.9.2.418 (Cucumberleaf Sunflower)
# 

# install.packages(c("mapview", "survey", "srvyr", "arcgislayers"))

# census_api_key("95496766c51541ee6f402c1e1a8658581285b759", install = TRUE, overwrite = TRUE)


# # load libraries
# #  NONE NEEDED


# Force dplyr's select to take precedence
select <- dplyr::select
filter <- dplyr::filter

# Options
options(scipen = 999)
options(qic.clshade = T) # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.linecol = 'black') # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.signalcol = "firebrick") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(qic.targetcol = "purple") # NO LONGER NEEDED; CHARTS ALL PREPARED WITH GGPLOT2 ONLY
options(DT.options = list(dom = 'pBlfrti')) # Add buttons, filtering, and top (t) pagination controls
options(shiny.maxRequestSize = 50 * 1024^2) # Set upload maximum to 50 MB
options(tigris_use_cache = TRUE)


# Set global theme for consistent plots
ggplot2::theme_set(ggplot2::theme_minimal(base_size = 20) + 
                   ggplot2::theme(plot.title = ggplot2::element_text(face = "bold",
                                                                      size = 26),
                                  plot.subtitle = ggplot2::element_text(face = "bold",
                                                                         size = 24),
                                  axis.title.x = ggplot2::element_text(face = "bold",
                                                                        size = 22),
                                  axis.title.y = ggplot2::element_text(face = "bold",
                                                                        size = 22),
                                  axis.text.x = ggplot2::element_text(face = "bold",
                                                                       size = 22,
                                                                       angle = 45,
                                                                       hjust = 1),
                                  legend.position = "bottom",
                                  strip.text = ggplot2::element_text(face = "bold"),
                                  panel.spacing.x = grid::unit(1.5,
                                                                "cm"),
                                  panel.spacing.y = grid::unit(1.5,
                                                                "cm"),
                                  plot.margin = ggplot2::margin(20,
                                                                 20,
                                                                 20,
                                                                 20,
                                                                 "pt")))


# Set seed for reproducibility
set.seed(123)

```


# Step 1: Creating Different Universes (Populations)

Conceptual thinking:

Create populations with different characteristics to sample from. This requires understanding different probability distributions.

Code skills needed:

- Using random number generation functions
- Setting seeds for reproducibility
- Constraining values to specific ranges

```{r}

base::set.seed(123)

# Create a random universe (1000 random integers between 1 and 1000)
random_universe <- base::sample(1:1000, 1000, replace = TRUE)

# Create non-random universes (several options)

# Option 1: Sequential numbers
sequential_universe <- 1:1000

# Option 2: Clustered data (4 distinct clusters)
clustered_universe <- c(
  stats::rnorm(250, mean = 100, sd = 20),
  stats::rnorm(250, mean = 300, sd = 20),
  stats::rnorm(250, mean = 600, sd = 20),
  stats::rnorm(250, mean = 900, sd = 20)
)
# Round to integers and ensure values are within 1-1000
clustered_universe <- base::pmin(1000, base::pmax(1, base::round(clustered_universe)))

# Option 3: Bimodal distribution
bimodal_universe <- c(
  stats::rnorm(500, mean = 250, sd = 100),
  stats::rnorm(500, mean = 750, sd = 100)
)
# Round to integers and ensure values are within 1-1000
bimodal_universe <- base::pmin(1000, base::pmax(1, base::round(bimodal_universe)))

# Option 4: Increasing variance (first half has low variance, second half high)
increasing_var_universe <- c(
  stats::rnorm(500, mean = 500, sd = 50),
  stats::rnorm(500, mean = 500, sd = 200)
)
# Round to integers and ensure values are within 1-1000
increasing_var_universe <- base::pmin(1000, base::pmax(1, base::round(increasing_var_universe)))
 


# create dataframes for ggplot2
df_random <- base::data.frame(random_universe)
df_sequential <- base::data.frame(sequential_universe)
df_clustered <- base::data.frame(clustered_universe)
df_bimodal <- base::data.frame(bimodal_universe)
df_increasing_var_universe <- base::data.frame(increasing_var_universe)


# Histograms of the universes
ggplot2::ggplot(df_random, 
                ggplot2::aes(x = random_universe)) +
  ggplot2::geom_histogram(binwidth = 10, fill = "lightgreen", color = "black", alpha = 0.7) +
  ggplot2::labs(title = "Histogram of Random Uniform Universe", x = "Value", y = "Frequency")


ggplot2::ggplot(df_sequential, 
                ggplot2::aes(x = sequential_universe)) +
  ggplot2::geom_histogram(binwidth = 10, fill = "lightgreen", color = "black", alpha = 0.7) +
  ggplot2::labs(title = "Histogram of Sequential", x = "Value", y = "Frequency")


ggplot2::ggplot(df_clustered, 
                ggplot2::aes(x = clustered_universe)) +
  ggplot2::geom_histogram(binwidth = 10, fill = "lightgreen", color = "black", alpha = 0.7) +
  ggplot2::labs(title = "Histogram of Clustered Universe", x = "Value", y = "Frequency")


ggplot2::ggplot(df_bimodal,
                ggplot2::aes(x = bimodal_universe)) +
  ggplot2::geom_histogram(binwidth = 10, fill = "lightgreen", color = "black", alpha = 0.7) +
  ggplot2::labs(title = "Histogram of Bi-Modal Universe", x = "Value", y = "Frequency")


ggplot2::ggplot(df_increasing_var_universe, 
                ggplot2::aes(x = increasing_var_universe)) +
  ggplot2::geom_histogram(binwidth = 10, fill = "lightgreen", color = "black", alpha = 0.7) +
  ggplot2::labs(title = "Histogram of Increasing Variance Universe", x = "Value", y = "Frequency")


```


# Step 2: Creating a Function to Take Samples and Calculate Variance

Conceptual thinking:

We need a function that can repeatedly sample from our universes and calculate the variance of each sample.

Code skills needed:

- Function definition
- Looping (for loops), or purrr::map()
- Sampling from vectors
- Statistical functions (var())
- Creating vectors to store results


When creating a function like calculate_sample_variances(), approach it by thinking about the overall process in steps. 

Identify the task: 

I need a function that:

- takes multiple random samples from a universe and 
- calculates the variance of each sample.

Define the inputs (parameters):

- universe: The population I'll sample from
- sample_size: How many elements to include in each sample
- num_samples = 100: How many samples to take (with a default value)


Plan the outputs: 

- I need to return a numeric vector containing all the sample variances.

Break down the algorithm:

- Create a container to store results (the empty vector)

Repeatedly:

- Take a random sample
- Calculate its variance
- Store that variance


Return all the variances


Code the implementation:

This approach follows a common pattern in R functions:

Create containers for outputs
Perform operations in a loop or vectorized operation
Return the result

The key skills demonstrated here are:

- Create empty vector with numeric(num_samples) (more efficient than growing a vector)
- Using a for loop to repeat an operation a specific number of times
- Storing results at specific indices of a vector
- Using sample() to draw random samples
- Using var() to calculate variance

If I were writing this for the first time, I might prototype it with a small dataset to ensure it works correctly before using it in a larger analysis.


```{r}
# Using a for loop

calculate_sample_variances <- function(universe, sample_size, num_samples = 100) {
  # Create empty numeric vector to store results
  variances <- numeric(num_samples)   # num_samples = sample size
  
  # Loop through and take samples
  for(i in 1:num_samples) {
    sample_data <- base::sample(universe, sample_size)
    variances[i] <- stats::var(sample_data)
  }
  
  base::return(variances)
}
```

## Same using purrr package

```{r}


calculate_sample_variances_purrr <- function(universe, sample_size, num_samples = 100) {
  # Use map_dbl to iterate and return a numeric vector
  variances <- purrr::map_dbl(1:num_samples, function(x) {
    sample_data <- base::sample(universe, sample_size)
    stats::var(sample_data)
  })
  
  return(variances)
}


```


## Same using purrr anonymous function

```{r}


calculate_sample_variances_purrr <- function(universe, sample_size, num_samples = 100) {
  purrr::map_dbl(1:num_samples, ~ stats::var(base::sample(universe, sample_size)))
}

```


# Step 3: Running the Experiment with Different Sample Sizes

Conceptual thinking:

See how sample size affects variance estimates, so test multiple sample sizes.

Code skills needed:

- Creating and managing lists
- Looping through vectors
- Iteratively building data structures
- String manipulation for naming

```{r}

# Using For loop

# Define sample sizes to test
sample_sizes <- c(10, 30, 50, 100, 200, 500)

# Create empty list to store results
results <- base::list()

# Loop through sample sizes
for(size in sample_sizes) {
  # Calculate variances for each universe
  random_variances <- calculate_sample_variances(random_universe, size)
  sequential_variances <- calculate_sample_variances(sequential_universe, size)
  clustered_variances <- calculate_sample_variances(clustered_universe, size)
  bimodal_variances <- calculate_sample_variances(bimodal_universe, size)
  increasing_var_variances <- calculate_sample_variances(increasing_var_universe, size)
  
  # Store in results list with descriptive names
  results[[paste0("size_", size)]] <- base::list(
    random = random_variances,
    sequential = sequential_variances,
    clustered = clustered_variances,
    bimodal = bimodal_variances,
    increasing = increasing_var_variances
  )
}

```

Same using purrr()

```{r}
# Using purrr()

# Define sample sizes to test
sample_sizes <- c(10, 30, 50, 100, 200, 500)

# Use map() to process each sample size and create a named list
results_purrr <- purrr::map(sample_sizes, function(size) {
  
  # Calculate variances for each universe
  random_variances_purrr <- calculate_sample_variances_purrr(random_universe, size)
  sequential_variances_purrr <- calculate_sample_variances_purrr(sequential_universe, size)
  clustered_variances_purrr <- calculate_sample_variances_purrr(clustered_universe, size)
  bimodal_variances_purrr <- calculate_sample_variances_purrr(bimodal_universe, size)
  increasing_var_variances_purrr <- calculate_sample_variances_purrr(increasing_var_universe, size)
  
  # Return a list for this sample size
  base::list(
    random = random_variances_purrr,
    sequential = sequential_variances_purrr,
    clustered = clustered_variances_purrr,
    bimodal = bimodal_variances_purrr,
    increasing = increasing_var_variances_purrr
  )
}) |> 
  # Set names for the resulting list elements
  purrr::set_names(paste0("size_", sample_sizes))

```

Visually compare the 2 methods (they should be very nearly the same)

```{r}


# Function to extract values from a nested list into a data frame
extract_values <- function(results_list, source_name) {
  result_df <- base::data.frame()
  
  for (size_name in names(results_list)) {
    size <- base::as.numeric(base::gsub("size_", "", size_name))
    
    for (universe_type in names(results_list[[size_name]])) {
      temp_df <- base::data.frame(
        sample_size = size,
        universe_type = universe_type,
        variance = results_list[[size_name]][[universe_type]],
        source = source_name
      )
      
      result_df <- base::rbind(result_df, temp_df)
    }
  }
  
  return(result_df)
}

# Create data frames from both lists
df1 <- extract_values(results, "for_loop")
df2 <- extract_values(results_purrr, "purrr")

# Combine the data frames
combined_df <- base::rbind(df1, df2)

# Plot comparison
ggplot2::ggplot(combined_df, 
                ggplot2::aes(x = variance, 
                             fill = source)) +
  ggplot2::geom_density(alpha = 0.5) +
  ggplot2::facet_grid(universe_type ~ sample_size, scales = "free") +
  ggplot2::labs(title = "Comparison of Variance Distributions",
                subtitle = "For loop vs purrr implementation",
                x = "Variance", 
                y = "Density"
                )

```


# Step 4: Converting Results to One Big Data Frame for Analysis

Conceptual thinking:

To analyze and visualize the results, convert the nested list into a tidy data frame.

Code skills needed:

- Data frame creation and manipulation
- List extraction
- String manipulation (for labeling)
- Combining data frames (rbind)

```{r}

# Create empty data frame
results_df <- base::data.frame()

# Loop through each sample size in results
for(size_name in names(results)) {
  # Extract numeric size from name
  size <- base::as.numeric(base::gsub("size_", "", size_name))
  
  # For each universe type and sample size, add data to results_df
  for(universe_type in names(results[[size_name]])) {
    # Create temporary data frame
    temp_df <- base::data.frame(
      sample_size = size,
      variance = results[[size_name]][[universe_type]],
      universe_type = universe_type
    )
    
    # Add to main results data frame
    results_df <- base::rbind(results_df, temp_df)
  }
}

```

# Step 5: Analyzing and Visualizing Results

Conceptual thinking:

Compare variances across universe types and sample sizes to understand patterns.

Code skills needed:

- Using ggplot2 for visualization
- Statistical tests (F-test, t-test)
- Calculating effect sizes
- Data grouping and summarization

```{r}


# Basic boxplot of variances by universe type and sample size
ggplot2::ggplot(results_df,
                ggplot2::aes(x = factor(sample_size), y = variance, color = universe_type)) +
  ggplot2::geom_boxplot() +
  ggplot2::labs(
    title = "Sample Variance by Sample Size and Universe Type",
    x = "Sample Size",
    y = "Variance",
    color = "Universe Type"
  ) 

# Calculate summary statistics
summary_stats <- results_df |>
  dplyr::group_by(sample_size, universe_type) |>
  dplyr::summarize(
    mean_variance = base::mean(variance),
    sd_variance = stats::sd(variance),
    n = dplyr::n(),
    se = sd_variance/base::sqrt(n),
    ci_lower = mean_variance - 1.96*se,
    ci_upper = mean_variance + 1.96*se
  )

# Plot with confidence intervals
ggplot2::ggplot(summary_stats, 
                ggplot2::aes(x = factor(sample_size), y = mean_variance, color = universe_type)) +
  ggplot2::geom_point(size = 3) +
  ggplot2::geom_errorbar(ggplot2::aes(ymin = ci_lower, ymax = ci_upper), width = 0.2) +
  ggplot2::labs(
    title = "Mean Sample Variance with 95% Confidence Intervals",
    x = "Sample Size",
    y = "Mean Variance",
    color = "Universe Type"
  ) 

```

# Step 6: Statistical Testing Between Universe Types

Conceptual thinking:

Formally test if the variances differ significantly between universe types.

Code skills needed:

- Hypothesis testing functions
- Looping through grouped data
- Creating summary data frames
- Understanding p-values and statistical significance


```{r}
# Create data frame for statistical tests
test_results <- base::data.frame()

# For each sample size
for(size in base::unique(results_df$sample_size)) {
  # Filter data for this sample size
  size_data <- dplyr::filter(results_df, sample_size == size)
  
  # Perform F-test between random and sequential universes
  random_data <- dplyr::filter(size_data, universe_type == "random")$variance
  sequential_data <- dplyr::filter(size_data, universe_type == "sequential")$variance
  
  f_test <- stats::var.test(random_data, sequential_data)
  
  # Add results to test_results data frame
  test_results <- base::rbind(test_results, base::data.frame(
    sample_size = size,
    comparison = "random vs sequential",
    p_value = f_test$p.value,
    significant = f_test$p.value < 0.05
  ))
  
  # Repeat for other comparisons as needed
}

print(test_results)

```

